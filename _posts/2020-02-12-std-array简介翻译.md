---
title: std-array简介翻译
date: 2020-02-12 11:13:09
categories:
- C++
- std
---

## Array class简介
array类是一个固定长度的容器：它线性存放着一定数量的元素。

由该类内部来说，一个array对象除了存储元素，不需要存储其他数据（甚至不用存储数组大小，因为数组大小已经作为模板参数，在编译阶段是不变的）。从存储大小来说，array类与普通数组（以中括号[]声明的数组）一样高效。该类仅仅在原来普通数组的基础上增加了一层，该层存储了数字和全局函数，因此array可以用作标准容器。

不像其他标准容器，array有固定大小，不能通过内存分配器进行元素的内存分配：它是一种封装了固定元素数组的一种聚合类型。因此，该类型的对象不能动态的扩展或缩减（如果想使用一个类似数组的、可以扩展的容器，可以使用vector来代替）。

大小为0的array是可以使用的，但是不能被解引用（例如成员函数front，back，data）。

不像其他的STL中的容器，交换两个array容器是一个线性操作，该操作将逐个交换容器中的元素，因此该操作是一个低效的操作。另一方面，这允许两个容器中的迭代器保持原有的容器关联。（On the other side, this allows the iterators to elements in both containers to keep their original container association.）

另一个array容器独有的特征是，它可以被当做tuple对象：<array>头文件重载了`get`函数，从而可以获取数组中的元素，这种特征好比它是一个tuple，也可以通过`tuple_size`和`tuple_element`来确定。

## 容器特性
### 顺序的：
顺序容器中的元素按照严格的线性顺序排列。 单个元素通过它在序列中的位置来访问。

### 连续存储的：
元素存储于连续的内存位置中，允许以固定时间随机访问元素。指向一个元素的指针可以通过偏移（位置）访问其他元素。

### 固定大小的聚合
容器通过隐式的构造函数和析构函数静态分配需要的内存空间。容器大小在编译阶段是固定的。没有内存或时间上的天花板（No memory or time overhead.）

## 模板参数
`T`：

包含元素的类型。`array::value_type`的别名。

`N`：

array的大小，表示元素的数量。

array的成员函数中，与上述名称相同的引用即模板参数。

## 成员类型
以下是array成员类型的别名。这些类型常被作为参数或者成员函数的返回类型：


| member type              | definition                                    | notes                          |
|--------------------------|-----------------------------------------------|--------------------------------|
| value\_type              | The first template parameter \(T\)            |                                |
| reference                | value\_type&                                  |                                |
| const\_reference         | const value\_type&                            |                                |
| pointer                  | value\_type\*                                 |                                |
| const\_pointer           | const value\_type\*                           |                                |
| iterator                 | a random access iterator to value\_type       | convertible to const\_iterator |
| const\_iterator          | a random access iterator to const value\_type |                                |
| reverse\_iterator        | reverse\_iterator&lt;iterator&gt;                  |                                |
| const\_reverse\_iterator | reverse\_iterator&lt;const\_iterator&gt;            |                                |
| size\_type               | size\_t                                       | unsigned integral type         |
| difference\_type         | ptrdiff\_t                                    | signed integral type           |

## 成员函数
### `std::array::begin`
``` cpp
iterator begin() noexcept;
const_iterator begin() const noexcept;
```

返回第一个元素的迭代器
返回指向array容器的第一个元素的迭代器。

注意，不像`array::front`，`array::front`返回的是第一个元素的引用，而这个函数返回的是指向第一个元素的随机访问迭代器。

对于大小为0的array，这个函数的返回值与`array::end`相同，但是返回的这个迭代器不能被解引用。


#### 返回类型
一个指向序列开头的迭代器。

如果当前的array对象是const的，该函数返回`const_iterator`，否则，返回`iterator`。

`iterator`和`const_iterator`这两种成员类型是随机访问迭代器类型（分别指向一个元素和一个const元素）。

#### 示例
``` cpp
// array::begin example
#include <iostream>
#include <array>

int main ()
{
  std::array<int,5> myarray = { 2, 16, 77, 34, 50 };

  std::cout << "myarray contains:";
  for ( auto it = myarray.begin(); it != myarray.end(); ++it )
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
```

#### 复杂度
常量复杂度

#### 数据竞争
该函数的调用不会访问容器中的元素，但是返回的迭代器可用于访问和修改元素。并发地访问和修改容器中不同的元素时安全的。

#### 异常安全
不会抛出异常：该成员函数不会抛出异常。返回的迭代器的拷贝构造函数和赋值都不会抛出异常。

### `std::array::end`
``` cpp 
iterator end() noexcept;
const_iterator end() const noexcept;
```

**返回最后一个的迭代器**
返回array容器中指向`past-the-end`元素的迭代器。

`past-the-end`元素是跟在array中最后一个元素之后的理论元素。它不指向任何元素，因此不能被解引用。

STL库中的函数指向的范围不包括结尾的迭代器，该函数常用于配合`array::begin`来指定包含容器中所有元素的范围。

在大小为0的array中，该函数的返回与`array::begin`相同。

#### 返回值
指向序列最后一个元素后面一个理论元素。

如果当前的array对象是const的，该函数返回`const_iterator`，否则，返回`iterator`。

`iterator`和`const_iterator`这两种成员类型是随机访问迭代器类型（分别指向一个元素和一个const元素）。

#### 示例
``` cpp
// array::end example
#include <iostream>
#include <array>

int main ()
{
  std::array<int,5> myarray = { 5, 19, 77, 34, 99 };

  std::cout << "myarray contains:";
  for ( auto it = myarray.begin(); it != myarray.end(); ++it )
    std::cout << ' ' << *it;

  std::cout << '\n';

  return 0;
}
```

#### 复杂度
常量复杂度

#### 数据竞争
同begin()

#### 异常安全
同begin()

### `std::array::rbegin`
``` cpp
reverse_iterator rbegin() noexcept;
const_reverse_iterator rbegin() const noexcept;
```

**返回指向最后一个元素的**
返回array容器中指向最后一个元素的反向迭代器。

`rbegin`指向`end`指向元素的前一个元素。

注意，不像`array::back`，它返回的是最后一个元素的引用，`rbegin`返回的是最后一个元素的反向随机访问迭代器。

#### 返回值
序列中最后一个元素的反向迭代器。

如果当前的array对象是const的，该函数返回`const_iterator`，否则，返回`iterator`。

`reverse_iterator`和`const_reverse_iterator`这两种成员类型是反向随机访问迭代器类型（分别指向一个元素和一个const元素）。

#### 示例
``` cpp
// array::rbegin/rend
#include <iostream>
#include <array>

int main ()
{
  std::array<int,4> myarray = {4, 26, 80, 14} ;

  std::cout << "myarray contains:";
  for ( auto rit=myarray.rbegin() ; rit < myarray.rend(); ++rit )
    std::cout << ' ' << *rit;

  std::cout << '\n';

  return 0;
}
```

#### 复杂度
常量复杂度

#### 数据竞争
该函数的调用不会访问容器中的元素，但是返回的迭代器可用于访问和修改元素。并发地访问和修改容器中不同的元素时安全的。

#### 异常安全
不会抛出异常：该成员函数不会抛出异常。返回的迭代器的拷贝构造函数和赋值都不会抛出异常。

### `std::array::rend`
``` cpp
reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;
```

返回array中指向第一个元素之前的理论元素（该元素被称为`reverse end`）的反向迭代器。

### `std::array::cbegin`
``` cpp
const_iterator cbegin() const noexcept;
```
**返回指向第一个元素的常量迭代器**

返回指向array容器中第一个元素的`const_iterator`。

一个`const_iterator`是一个指向内容为const类型的迭代器。这个迭代器可以通过自增自减来偏移（除非这个迭代器本身是const修饰的），除了不能修改指向的内容，其他功能和`array::begin`相同。

### `std::array::cend`
``` cpp
const_iterator cend() const noexcept;
```

指向array容器中的`past-the-end`元素的`const_iterator`。

`const_iterator`指向的内容是const的。这个迭代器可以自增和自减（除非迭代器本身是const的），除了不能修改指向的元素内容，其他效果和`array::end`相同。

### `std::array::crbegin`
``` cpp
const_reverse_iterator crbegin() const noexcept;
```

返回指向array中最后一个元素的`const_reverse_iterator`。

`const_reverse_iterator`是一个执行const内容的迭代器，并且进行反向迭代。这个迭代器可以自增和自减（除非迭代器本身是const的），除了不能修改指向的元素内容，其他效果和`array::rbegin`相同。

### `std::array::crend`
``` cpp
const_reverse_iterator crend() const noexcept;
```

返回array中指向第一个元素之前的理论元素（被称为reverse end）的`const_reverse_iterator`。

`const_reverse_iterator`是一个执行const内容的迭代器，并且进行反向迭代。这个迭代器可以自增和自减（除非迭代器本身是const的），除了不能修改指向的元素内容，其他效果和`array::rend`相同。

### `std::array::size`
``` cpp
constexpr size_type size() noexcept; 
```

返回array容器中的元素数量。

array对象的大小和第二个模板参数相同。

与`sizeof`不同，`sizeof`是用来返回多少字节的，该函数用来返回array中的元素个数。

### `std::array::max_size`
``` cpp
constexpr size_type max_size() noexcept;
```

返回array容器能容纳的最多的元素个数。

`max_size`总是和`size`相同，是第二个模板参数初始化的值。

### `std::array::empty`
```cpp
constexpr bool empty() noexcept;
```
返回array容器是否为空，即`size`是否为0。


### `std::array::operator[]`
``` cpp
reference operator[] (size_type n);
const_reference operator[] (size_type n) const;
```



