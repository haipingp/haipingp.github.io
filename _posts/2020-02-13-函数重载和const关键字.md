---
title: 函数重载和const关键字
date: 2020-02-13 21:37:09
categories:
- C++
---

## 成员函数为const时
### 示例1
* 代码

``` cpp
#include<iostream> 
using namespace std; 

class Test 
{ 
protected: 
	int x; 
public: 
	Test (int i):x(i) { } 
	void fun() const
	{ 
		cout << "fun() const called " << endl; 
	} 
	void fun() 
	{ 
		cout << "fun() called " << endl; 
	} 
}; 

int main() 
{ 
	Test t1 (10); 
	const Test t2 (20); 
	t1.fun(); 
	t2.fun(); 
	return 0; 
} 

```

* 输出
```
fun() called
fun() const called
```

* 这里const对象调用了const函数，非const对象调用了非const对象。

`void fun() const`和`void fun()`的函数签名看着相同，但是作为成员函数，`this`也是隐含的一个函数参数。

非const对象可以调用`void fun() const`和`void fun()`中的任意一个，但是优先调用`void fun()`。如果只有const函数，那么非const对象也可以调用const函数。

* 应用场景：我们常常在一些应用中，同时定义const和非const函数的同名函数，const函数用于返回const的引用或指针，非const函数用于返回非const的引用或指针。

## 当一般的函数参数为const时
### 示例2
* 代码

``` cpp
// PROGRAM 1 (Fails in compilation) 
#include<iostream> 
using namespace std; 

void fun(const int i) 
{ 
	cout << "fun(const int) called "; 
} 
void fun(int i) 
{ 
	cout << "fun(int ) called " ; 
} 
int main() 
{ 
	const int i = 10; 
	fun(i); 
	return 0; 
} 

```

``` cpp
// PROGRAM 2 (Compiles and runs fine) 
#include<iostream> 
using namespace std; 

void fun(char *a) 
{ 
cout << "non-const fun() " << a; 
} 

void fun(const char *a) 
{ 
cout << "const fun() " << a; 
} 

int main() 
{ 
const char *ptr = "GeeksforGeeks"; 
fun(ptr); 
return 0; 
} 

```

* 上述PROGRAM1不能通过编译：Compiler Error: redefinition of 'void fun(int)'，PROGRAM2能通过编译

* 这是因为C++允许参数为引用或指针时，可以通过const类型的函数参数进行重载

* 可以看到PROGRAM1中，无论哪个函数，传进去的int值都是按值传递的，函数中不会修改main中传进去的int值，因此这两个函数其实效果是相同的，所以会有重定义的错误

* 但是在PROGRAM2中，函数可以通过指针对main函数传进去的值进行修改，因此函数参数加了const和不加const会影响函数的效果（是否可以对main中传进去的值进行修改）不同。因此不会报错

### 示例3
* 通过示例2可知，以下的代码也是可以通过编译的：

``` cpp
#include<iostream> 
using namespace std; 

void fun(const int &i) 
{ 
	cout << "fun(const int &) called "; 
} 
void fun(int &i) 
{ 
	cout << "fun(int &) called " ; 
} 
int main() 
{ 
	const int i = 10; 
	fun(i); 
	return 0; 
} 

```

